# include <stdio.h>
/*指针要重点关注其指向的对象是谁，因为这关系到指针移动一步的跨度有多大,以及两个
  指针之间是否可以相互传递值
注意：
    1. 二级指针 int **p 与二维数组名没有卵的关系，两者所指的对象根本不是同一类
       东西，顶多功能上有些相似
    2. 要生成对应的对应的指针变量，关键要搞清楚已有的指针所指的元素对象是什么
    3. C规定，数组名是首元素地址*/

int main(){
    int (*p)[4], i;   // p是一个指向含有4个元素的数组指针
                      // ==> p的一次移动，跨度是一个一维数组
    int a[1][4]; //经过测试：a既不能直接赋值给一级指针，也不能直接赋值给二级指针
                 //a是一个指向4个元素的数组的指针
    p = a;  // 这里将p指向可存储变量的空间
    printf("Input four array elemenets:");
    for(i=0; i<4; i++) scanf("%d", *p+i);// 没有给P赋值前只有一个指针变量的空
                                         //间，且该指针的值在初始化的时候还是
                                         //随机的，故而其所指空间不一定可以存值
                                         //所以这里不给指针赋值，就移动指针进行
                                         //空间赋值是有问题的
    for(i=0; i<4; i++) printf("%d ", *(*p+i));
    printf("\n");
    
   //  int **p1;
   // p1 = a;   错，数组名和二级指针没有卵的关系
   // printf("The two level pointer results:\n");
   // for(i=0; i<4; i++) printf("%d ", *(*p1+i));
    int *pb, b[5];  // 数组名b为首元素地址，而首元素是一个整型，故而要获得该数组
                    // 地址，只需要一个指向整型的指针即可
    printf("Input five array elements:");
    for(i=0; i<5; i++) scanf("%d", b+i);
    pb = b;
    printf("b:%p, pb:%p\n",b, pb);  
    for(i=0; i<5; i++) printf("%d ", *(pb+i));
    putchar('\n');

    //int **pa;   
    // pa = (int **)a; 错，即使强制类型转换了，由于两者所指的对象本质上不同：
    // pa指向的是一个*pa的指针，而a是指向一个数组，两个本不是同一个东西
    //printf("a:%o, pa:%o\n",a, pa);
    // for(i=0; i<4; i++) printf("%d ", **(pa+i));
    // putchar('\n');
   
    return 0;
}
