# include <stdio.h>

/*在定义一个结构体的时候，不能使用没有定义好的结构类型来定义成员，具体原因尚未
  清楚，猜测可能是递归定义，内存无法分配的原因，之所以可以在当前定义的结构体内
  定义指向当前结构体的指针，是因为，在C中，所有的指针都是4字节32位大小的，都是
  用来存放地址的，所以大小可计算
注意：
    1. 结构体的空间是在使用结构体类型定义变量的时候，编译系统进行分配的，
       在定义结构的时候是不会分配的，上面之所以会说内存无法分配，是觉得编译系统
       在语法检查的时候，应该会预先计算统计下，这里要分配多少空间，如果都算不出
       来，那就更不要说是分配空间了
*/

struct student{
    int num;
    char name[20];
    float score;
  //struct student a; // 递归定义，没有出口，编译系统无法计算大小，无法分配类存
                      // 报错， field 'a' has incomplete type
    struct student *p;  // 对于一个编译器来说，指针的大小是已知的，所以该结构的
                        // 大小也是已知的，编译系统可以为之分配内存，编译通过
                        // 所有指针变量的空间占用都是4字节32位
};


int main(){
    struct student Boss;
    return 0;
}
